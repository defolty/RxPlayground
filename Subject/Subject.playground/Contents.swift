import Foundation
import RxSwift
import RxRelay

public func example(of description: String, action: () -> Void) {
    print("\n--- Example of:", description, "---")
    action()
}

/// В RxSwift существует четыре типа `Subject`:
/// `PublishSubject`: Изначально пуст и излучает подписчикам только новые элементы.
/// `BehaviorSubject`: Начинает с начального значения и воспроизводит его или последний элемент новым подписчикам.
/// `ReplaySubject`: Инициализируется с размером буфера и будет поддерживать буфер элементов до этого размера и воспроизводить его новым подписчикам.
/// `AsyncSubject`: Выдает только последнее следующее событие в последовательности, и только тогда, когда субъект получает завершенное событие.
///                Это редко используемый тип субъекта, и вы не будете использовать его в этой книге. Он приведен здесь для полноты картины.

    // MARK: - PublishSubject

// Вы только что создали PublishSubject.
// Это подходящее название, потому что, подобно издателю газеты, он будет получать информацию, а затем публиковать ее подписчикам.
// Он имеет тип String, поэтому может принимать и публиковать только строки.
// После инициализации он готов к приему строк.
// Субъекты публикации удобны, когда вы просто хотите, чтобы подписчики получали уведомления о новых событиях с того момента, когда они подписались, до тех пор,
// пока они не отпишутся, или пока субъект не завершится событием завершения или ошибки.
// -
// RxSwift также предоставляет концепцию под названием `Relays`.
// RxSwift предоставляет два из них, названные `PublishRelay и BehaviorRelay`.
// Они обертывают соответствующие субъекты, но принимают и передают только следующие события.
// Вы не можете добавить завершенное событие или событие ошибки в реле, поэтому они отлично подходят для не завершающихся последовательностей.

example(of: "PublishSubject") {
    
    // Subject действуют как наблюдаемый и как наблюдатель.
    // Ранее вы видели, как они могут получать события, а также быть подписанными на них.
    // В приведенном примере субъект получал следующие события, и для каждого из них он поворачивался и излучал его своему подписчику.
    let subject = PublishSubject<String>()
    
    subject.on(.next("Is anyone listening?"))
    
    let subscriptionOne = subject
        .subscribe(onNext: { string in
            print(string)
        })
    
    subject.on(.next("1"))
    subject.onNext("2")
    /* output
     --- Example of: PublishSubject ---
     1
     2
     */
    
    let subscriptionTwo = subject
        .subscribe { event in
            print("2", event.element ?? event)
        }
    
    subject.onNext("3")
    /* output
     --- Example of: PublishSubject ---
     1
     2
     3
     2 3 // 3 печатается дважды, один раз для subscriptionOne и один раз для subscriptionTwo.
     */
    
    // Добавьте этот код, чтобы прекратить subscriptionOne, а затем добавьте еще одно следующее событие в тему:
    subscriptionOne.dispose()
    subject.onNext("4")
    // Значение 4 печатается только для subscriptionTwo, потому что subscriptionOne была утилизирована.
     
    // 1 - Добавьте завершенное событие на объект, используя удобный метод для on(.completed). Это завершает наблюдаемую последовательность объекта.
    subject.onCompleted()
    
    // 2 - Добавьте еще один элемент на объект. Он не будет выдан и напечатан, потому что объект уже завершился.
    subject.onNext("5")
    
    // 3 - Утилизируйте подписку.
    subscriptionTwo.dispose()
    
    let disposeBag = DisposeBag()
    
    // 4 - Подпишитесь на объект, на этот раз добавив его одноразовый элемент в мешок утилизации.
    subject
        .subscribe {
            print("3)", $0.element ?? $0)
        }
        .disposed(by: disposeBag)
    
    subject.onNext("?")
    /* output
     2 completed
     3) completed
     -
     Может быть, новый подписчик 3) вернет субъект в рабочее состояние? Нет, но вы все равно получите повторное воспроизведение завершенного события.
     */
}

    // MARK: - BehaviorSubjects

// BehaviorSubjects работают аналогично publishSubjects, за исключением того, что они будут воспроизводить последнее следующее событие новым подписчикам.
// 1 - Определите тип ошибки для использования в последующих примерах.
enum MyError: Error {
    case anError
}

// 2 - Развивая использование тернарного оператора в предыдущем примере, вы создаете вспомогательную функцию для печати элемента,
// если он есть, ошибки, если она есть, или самого события.
func print<T: CustomStringConvertible>(label: String, event: Event<T>) {
    print(label, (event.element ?? event.error) ?? event)
}
 
example(of: "BehaviorSubjects") {
    // 3 - Создайте новый экземпляр BehaviorSubject. Его инициализатор принимает начальное значение
    let subject = BehaviorSubject(value: "Initial Value")
    let disposeBag = DisposeBag()
}

 
